#!/bin/sh
set -e
SNAZZER_VERSION=0.2
SNAZZER_MEAS_LOCK_DIR="/var/run/snazzer-measure.lock"
SNAZZER_SNAPSHOTZ_PERMS=0700

if [ "$SNAZZER_USE_UTC" = "1" ]; then
    SNAZZER_DATE=$(date -u +"%Y-%m-%dT%H%M%SZ")
else
    SNAZZER_DATE=$(date +"%Y-%m-%dT%H%M%S%z")
fi
if [ "$(id -u)" = "0" ]; then
    SUDO=""
else
    SUDO="sudo"
fi
if [ -z "$SNAZZER_MEASUREMENTS_EXCLUDE_FILE" ]; then
    SNAZZER_MEASUREMENTS_EXCLUDE_FILE=".snapshot_measurements.exclude"
fi
# Keep in sync with the POD!
if [ -z "$SNAZZER_SUBVOLS_EXCLUDE_FILE" ]; then
    SNAZZER_SUBVOLS_EXCLUDE_FILE="/etc/snazzer/exclude.patterns"
fi

if ! $SUDO test -e "$SNAZZER_SUBVOLS_EXCLUDE_FILE"; then
    MISSING_SUBVOLS_EXCL_FILE="$SNAZZER_SUBVOLS_EXCLUDE_FILE"
    SNAZZER_SUBVOLS_EXCLUDE_FILE=$(mktemp)
    cat <<HERE > "$SNAZZER_SUBVOLS_EXCLUDE_FILE"
var/cache
var/lib/docker
.snapshots
*secret*
HERE
    cat <<HERE >&2
WARN: '$MISSING_SUBVOLS_EXCL_FILE' missing, defaulting to $SNAZZER_SUBVOLS_EXCLUDE_FILE:
HERE
    cat "$SNAZZER_SUBVOLS_EXCLUDE_FILE"
fi

assert_mountpoint() {
    DIR_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    if ! eval "mountpoint -q '$DIR_ESC'"; then
        echo "ERROR: '$DIR_ESC' is not a filesystem mountpoint" >&2
        exit 2
    fi
}

assert_subvolume() {
    DIR_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    if ! eval "$SUDO btrfs subvolume show '$DIR_ESC' >/dev/null 2>&1"; then
        echo "ERROR: '$DIR_ESC' is not a btrfs subvolume" >&2
        exit 3
    fi
}

assert_btrfs_tools() {
    if ! $SUDO btrfs subvolume snapshot --help >/dev/null; then
        echo 'ERROR: btrfs command not found' >&2
        exit 11
    fi
}

glob2grep_file() {
    FILE_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    OUT=$(mktemp)

    eval "$SUDO cat '$FILE_ESC'" | sed 's|[$.^]|\\&|g' | sed 's/\*/\.*/g' > "$OUT"

    echo "$OUT"
}

list_subvolumes() {
    DIR="$1"
    DIR_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    DO_INVERT="$2"
    if [ "$DO_INVERT" = "--excluded" ]; then
        GREP="grep"
    else
        GREP="grep -v"
    fi
    assert_mountpoint "$DIR"
    if [ "$DIR" != "/" ]; then
            DIR="$DIR/"
    fi
    EXCL_FILE=$(glob2grep_file "$SNAZZER_SUBVOLS_EXCLUDE_FILE")
    eval "$SUDO btrfs subvolume list -ot '$DIR_ESC'" | tail -n+3 | \
        $GREP -f "$EXCL_FILE" | grep -v '\.snapshotz' | \
        sed 's/^[0-9]*[ \t]*[0-9]*[ \t]*[0-9]*[ \t]*//g' | \
        while read SUBVOL; do echo "${DIR}$SUBVOL"; done
    rm "$EXCL_FILE"
}

report_subvols_excluded() {
    DIR="$1"
    NUM=$(list_subvolumes "$DIR" --excluded | wc -l)

    if [ "$NUM" != "0" ]; then
        echo ""
        echo "$NUM subvolumes excluded by $SNAZZER_SUBVOLS_EXCLUDE_FILE."
    fi
}

# Get a list of mountpoints from the unique list of devices showing up as
# mounted btrfs filesystems. We don't want to list bind mounts or manually
# mounted subvols (who already have their parent/container filesystems mounted)
# as separate filesystems, that would result in multiple snapshotting of those
# subvols later on.
# SMELL: what if a subvol is mounted some place other than its path name?
# NOTE: We could use df --output=target/source, but we're pretending to keep
# GNU-isms to a minimum - so we use awk instead.
list_btrfs_mountpoints() {
    EXCL_FILE=$(glob2grep_file "$SNAZZER_SUBVOLS_EXCLUDE_FILE")
    df -t btrfs | tail -n+2 | awk '{ print $1 }' | sort |uniq | \
        while read DEV; do df "$DEV" | tail -n+2 ; done | \
        awk '{ print $6 }' | grep -v '\.snapshotz' | grep -v -f "$EXCL_FILE"
    rm "$EXCL_FILE"
}

get_subvol_path() {
    DIR_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    UUID=$(eval "$SUDO btrfs subvolume show '$DIR_ESC'" | \
        sed -n 's/^[ \t]*uuid:[ \t]*\(.*\)/\1/p')
    if [ -n "$UUID" ]; then
        eval "$SUDO btrfs subvolume list -u '$DIR_ESC'" | \
            sed -n "s/^.*$UUID[ \t]*path[ \t]*\\(.*\\)/\\1/p"
    fi
}

# List the excluded subvols relative to DIR
list_excluded_subvols() {
    DIR="$1"
    DIR_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    SUBVOL_PATH_ESC=$(get_subvol_path "$DIR" | sed -e 's/[]$*.^|[]/\\&/g' | \
        sed "s/'/'\\\\''/g")
    eval "$SUDO btrfs subvolume list -o '$DIR_ESC' | \
        sed -n 's|.*path $SUBVOL_PATH_ESC[/]*\\(.*\\)|\\1|p'"
}

assert_missing() {
    THING_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    if eval "$SUDO test -e '$THING_ESC'"; then
        cat <<HERE >&2
ERROR: '$THING_ESC' exists, aborting
HERE
        exit 6
    fi
}

assert_exists() {
    THING_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    if ! eval "$SUDO test -e '$THING_ESC'"; then
        cat <<HERE >&2
ERROR: '$THING_ESC' is missing, aborting
HERE
        exit 4
    fi
}

build_snapshot_cmd() {
    SUBVOL="$1"
    SUBVOL_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    SNAP_DIR_ESC=$(echo "$2" | sed "s/'/'\\\\''/g")
    if [ "$SUBVOL" = "/" ]; then
        EXCL_FILE_ESC="/$SNAZZER_MEASUREMENTS_EXCLUDE_FILE"
    else
        EXCL_FILE_ESC="${SUBVOL_ESC}/$SNAZZER_MEASUREMENTS_EXCLUDE_FILE"
    fi

    # The stdin/out cat below, is in case we're leaning on sudo...
    cat <<HERE
cat <<EXCL | $SUDO tee '$EXCL_FILE_ESC' >/dev/null
$( eval "list_excluded_subvols '$SUBVOL_ESC'" | sed -e 's|[`$]|\\&|g')
EXCL
$SUDO btrfs subvolume snapshot -r '$SUBVOL_ESC' '$SNAP_DIR_ESC'
$SUDO rm '$EXCL_FILE_ESC'
HERE
}

snapshot() {
    SUBVOL="$1"
    SUBVOL_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    assert_subvolume "$SUBVOL"
    assert_missing "$SUBVOL/$SNAZZER_MEASUREMENTS_EXCLUDE_FILE"
    if [ "$SUBVOL" = "/" ]; then
        DEST="/.snapshotz"
        DEST_ESC="/.snapshotz"
    else
        DEST="$SUBVOL/.snapshotz"
        DEST_ESC="$SUBVOL_ESC/.snapshotz"
    fi
    eval "$SUDO mkdir -p '$DEST_ESC' --mode=$SNAZZER_SNAPSHOTZ_PERMS"
    if [ "$DRY_RUN" = "1" ]; then
        CMD="cat"
    else
        CMD="/bin/sh -e"
    fi
    build_snapshot_cmd "$SUBVOL" "$DEST/$SNAZZER_DATE" | $CMD
    assert_missing "$SUBVOL/$SNAZZER_MEASUREMENTS_EXCLUDE_FILE"
}

list_dirs() {
    DIR_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    eval "$SUDO ls -F '$DIR_ESC'" | sed -n 's|^\(.*\)/$|\1|p'
}

# List directories to be pruned under a foo/.snapshotz dir, newline separated.
prune_shotz_dirs() {
    SUBVOL_SHOTZ="$1"
    SUBVOL_SHOTZ_ESC=$(echo "$SUBVOL_SHOTZ" | sed "s/'/'\\\\''/g")
    assert_missing "$SUBVOL_SHOTZ/.incomplete"
    eval "$SUDO ls '$SUBVOL_SHOTZ_ESC'" | snazzer-prune-candidates | \
        while read SNAP_NAME; do echo "$SUBVOL_SHOTZ/$SNAP_NAME"; done
}

# We can't just use ls --quoting-style=shell feature, this makes
# snazzer-prune-candidates sad when the last char in a line is '
build_prune_cmd() {
    PRUNE_LIST=$(echo -n "'"; echo -n "$1" | sed "s/'/'\\\\''/g" | \
        sed ":a;N;\$!ba;s/\\n/' '/g"; echo -n "'")
    cat <<HERE
$SUDO btrfs subvolume delete $PRUNE_LIST
HERE
}

prune() {
    SUBVOL="$1"
    SUBVOL_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    if [ "$SUBVOL" = "/" ]; then
        SUBVOL_SHOTZ="/.snapshotz"
        SUBVOL_SHOTZ_ESC="/.snapshotz"
    else
        SUBVOL_SHOTZ="$SUBVOL/.snapshotz"
        SUBVOL_SHOTZ_ESC="$SUBVOL_ESC/.snapshotz"
    fi
    assert_subvolume "$SUBVOL"
    assert_exists "$SUBVOL_SHOTZ"
    PRUNE_LIST=$(prune_shotz_dirs "$SUBVOL_SHOTZ")
    NUM_PRUNE=$(echo "$PRUNE_LIST" | grep . | wc -l)
    NUM_AVAIL=$(list_dirs "$SUBVOL_SHOTZ" | grep . | wc -l)
    echo "'$SUBVOL_SHOTZ_ESC': pruning $NUM_PRUNE of $NUM_AVAIL"
    if [ "$NUM_PRUNE" != "0" ]; then
        if [ "$DRY_RUN" = "0" -a "$DO_FORCE" = "1" ]; then
            CMD="/bin/sh -e"
        elif [ "$DRY_RUN" = "1" ]; then
            CMD="cat"
        else
            echo "ERROR: --prune expected --force or --dry-run" >&2
            exit 5
        fi
        if [ -n "$PRUNE_LIST" ]; then
            build_prune_cmd "$PRUNE_LIST" | $CMD | \
                grep -v 'Transaction commit: none (default)'
        fi
    fi
}

measure_lock() {
    if ! $SUDO test -e "$SNAZZER_MEAS_LOCK_DIR"; then
        true
    elif ! $SUDO test -e "$SNAZZER_MEAS_LOCK_DIR/pid"; then
        echo "ERROR: $SNAZZER_MEAS_LOCK_DIR exists without pidfile 'pid'" >&2
        echo "  Please report this to the author and/or remove the dir" >&2
        exit 7
    else
        OLD_PID=$($SUDO cat "$SNAZZER_MEAS_LOCK_DIR/pid")
        if ps --pid=$OLD_PID >/dev/null; then
            echo "ERROR: A snazzer --measure invocation is already running" >&2
            echo "  $SNAZZER_MEAS_LOCK_DIR/pid is $OLD_PID" >&2
            exit 7
        else
            cat <<HERE >&2
WARN: Previous snazzer --measure invocation PID $OLD_PID exited ungracefully;
$SNAZZER_MEAS_LOCK_DIR/pid stale
HERE
            $SUDO rm -v "$SNAZZER_MEAS_LOCK_DIR/pid"
            $SUDO rmdir -v "$SNAZZER_MEAS_LOCK_DIR"
        fi
    fi
    $SUDO mkdir "$SNAZZER_MEAS_LOCK_DIR"
    echo "$$" | $SUDO tee "$SNAZZER_MEAS_LOCK_DIR/pid" >/dev/null
}

measure_unlock() {
    eval "$SUDO rm '$SNAZZER_MEAS_LOCK_DIR/pid'"
    eval "$SUDO rmdir '$SNAZZER_MEAS_LOCK_DIR'"
}

build_measure_cmd() {
    SUBVOL_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    REPORT_ESC=$(echo "$2" | sed "s/'/'\\\\''/g")

    cat <<HERE
snazzer-measure '$SUBVOL_ESC' >> '$REPORT_ESC';
HERE
}

# If DO_FORCE=1, measure all snapshots regardless of whether the hostname seems
# to already have made a measurement in the past
measure() {
    SUBVOL="$1"
    SUBVOL_ESC=$(echo "$1" | sed "s/'/'\\\\''/g")
    OLD_PWD_ESC=$(pwd | sed "s/'/'\\\\''/g")
    if [ "$SUBVOL" = "/" ]; then
        SUBVOL_SHOTZ="/.snapshotz"
        SUBVOL_SHOTZ_ESC="/.snapshotz"
    else
        SUBVOL_SHOTZ="$SUBVOL/.snapshotz"
        SUBVOL_SHOTZ_ESC="$SUBVOL_ESC/.snapshotz"
    fi
    assert_subvolume "$SUBVOL"
    assert_exists "$SUBVOL_SHOTZ"
    measure_lock
    if ! eval "$SUDO test -e '$SUBVOL_SHOTZ_ESC/.measurements'"; then
        eval "$SUDO mkdir '$SUBVOL_SHOTZ_ESC/.measurements'"
    fi
    SNAP_LIST_AVAIL=$(eval "$SUDO ls '$SUBVOL_SHOTZ_ESC'")
    if [ "$DO_FORCE" = "1" ]; then
        SNAP_LIST="$SNAP_LIST_AVAIL"
    else
        # Collect measurements that don't mention our hostname
        SNAP_LIST=$(eval "$SUDO grep -rsL '^> on $(hostname) at' \
            '$SUBVOL_SHOTZ_ESC/.measurements'" | \
            while read SNAP_FULLPATH; do basename "$SNAP_FULLPATH"; done)
        # Collect snapshot names without any measurements at all
        # SMELL: What a nasty way to do this. We're trying to limit the number
        # of different things a $SUDO user would need to open up in sudoers, but
        # that's a pretty terribly tedious use-case.
        SNAP_MISSING=$(echo "$SNAP_LIST_AVAIL" | while read SNAP_NAME
            do eval "$SUDO test -e \
                '$SUBVOL_SHOTZ_ESC/.measurements/$SNAP_NAME'" || \
                    echo "$SNAP_NAME"
            done)
        SNAP_LIST=$(echo "$SNAP_LIST"; echo "$SNAP_MISSING")
    fi
    # grep . so we don't count final newline
    NUM_MEAS=$( echo "$SNAP_LIST" | grep . | wc -l )
    NUM_AVAIL=$( echo "$SNAP_LIST_AVAIL" | grep . | wc -l)
    echo "'$SUBVOL_ESC': measuring $NUM_MEAS of $NUM_AVAIL"
    if [ "$DRY_RUN" = "1" ]; then
        CMD="cat"
        PREPOST_CMD="echo"
    else
        CMD="/bin/sh -e"
        PREPOST_CMD="eval"
    fi
    $PREPOST_CMD "cd '$SUBVOL_SHOTZ_ESC/.measurements'"
    echo "$SNAP_LIST" | grep . | while read SNAP_NAME
    do
        echo "  $SNAP_NAME"
        build_measure_cmd "../$SNAP_NAME" "$SNAP_NAME" | $CMD
    done
    $PREPOST_CMD "cd '$OLD_PWD_ESC'"
    measure_unlock
}

do_multiple() {
    DO_ACTION="$1"
    shift
    for SUBVOL in "$@"; do
        if [ "$SUBVOL" != "/" ]; then
            SUBVOL=$(echo "$SUBVOL" | sed 's|/$||g')
        fi
        case "$DO_ACTION" in
            'snapshot') snapshot "$SUBVOL"
                        ;;
            'prune')    if ! which snazzer-prune-candidates >/dev/null; then
                            echo 'ERROR: snazzer-prune-candidates not found' >&2
                            exit 10
                        fi
                        prune "$SUBVOL"
                        ;;
            'measure')  if ! which snazzer-measure >/dev/null; then
                            echo 'ERROR: snazzer-measure not found' >&2
                            exit 10
                        fi
                        measure "$SUBVOL"
                        ;;
            'list-subvolumes') echo "$SUBVOL"
                        ;;
            'list-snapshots')
                        if [ "$SUBVOL" = "/" ]; then
                            $SUDO btrfs subvolume list -o "$SUBVOL" | \
                                grep '\.snapshotz' | \
                                sed -n "s|.*path .*\.snapshotz/\(.*\)|/.snapshotz/\1|p"
                        else
                            MOUNTPOINT=$(echo "$SUBVOL" | \
                                sed 's|[&*$.^\|]|\\&|g')
                            $SUDO btrfs subvolume list -o "$SUBVOL" | \
                                grep '\.snapshotz' | \
                                sed -n "s|^.*path .*\.snapshotz/\(.*\)|$MOUNTPOINT/\.snapshotz/\1|p"
                        fi
                        ;;
            *) echo "ERROR: invalid cmd '$DO_ACTION'"
               exit 1
               ;;
        esac
    done
    sync
}

test_img_write() {
    FILE="$1"
    SIZE="$2"
    dd if=/dev/urandom of="$FILE" bs="$SIZE" count="1"
}

test_img_populate() {
    MNT="$1"
    OLD_PWD_ESC=$(pwd | sed "s/'/'\\\\''/g")
    cd "$MNT"
    for SUBVOL in srv home etc/secrets var/lib/docker/btrfs var/cache \
        usr/local/src "this is/something with/spaces in it" \
        'BAM_$(ls *)/`echo sierra`' \
        'echo `ls "/"; ls /;`; ~!@#$%^&*()_+-='"'"'[]'"'"'{}|:<>,./?'; do
        SUBVOL_PARENT="$(dirname "$SUBVOL")"
        SUBVOL_NAME="$(basename "$SUBVOL")"
        mkdir -p "$SUBVOL_PARENT"
        btrfs subvolume create "$SUBVOL"
        test_img_write "$SUBVOL/${SUBVOL_NAME}_junk" 500K
        if [ "$SUBVOL_PARENT" = "." ]; then
            test_img_write "${SUBVOL_NAME}_junk" 500K
        else
            test_img_write "${SUBVOL_PARENT}_${SUBVOL_NAME}_junk" 500K
        fi
    done
    eval "cd '$OLD_PWD_ESC'"
}

test_img_create() {
    IMG="$1"
    if [ -z "$IMG" ]; then
        echo "ERROR: --generate-test-img missing filename" >&2;
        exit 1;
    fi
    MNT="$(mktemp -d)"
    truncate -s 40M "$IMG"
    mkfs.btrfs "$IMG"
    mount "$IMG" "$MNT"
    test_img_populate "$MNT"
    umount "$MNT"
    rmdir "$MNT"
}

DO_ACTION="snapshot"
DO_FORCE=0
DRY_RUN=0
DO_ALL=0

while [ "$(echo "$1" | grep -c "^-")" != 0 ]
do
    case "$1" in
        -h | --help ) pod2usage -exit 0 "$0"; exit ;;
             --man ) pod2usage -exit 0 -verbose 3 "$0"; exit ;;
             --man-roff ) pod2man --release=$SNAZZER_VERSION "$0"; exit ;;
             --man-markdown )
             cat <<HERE | perl -Mstrict
if ( eval { require Pod::Markdown; 1; } ) {
    Pod::Markdown->new->filter('$0');
}
else {
    print STDERR "ERROR: --man-markdown requires Pod::Markdown\n\$@\n";
    exit 9;
}
HERE
                 exit ;;
        -p | --prune ) DO_ACTION="prune"; ;;
        -m | --measure ) DO_ACTION="measure"; ;;
             --list-subvolumes ) DO_ACTION="list-subvolumes"; ;;
             --list-snapshots ) DO_ACTION="list-snapshots"; ;;
        -f | --force ) DO_FORCE=1; ;;
        -d | --dry-run ) DRY_RUN=1; ;;
        -a | --all ) DO_ALL=1; ;;
        -g | --generate-test-img ) test_img_create "$2"; exit; ;;
        * ) echo "ERROR: Invalid argument '$1'" >&2 ; exit ;;
    esac
    shift
done

if [ -z "$1" -a "$DO_ALL" != "1" ]; then
    pod2usage -exit 0 "$0"
    echo "ERROR: Missing argument" >&2
    exit 1
elif [ "$DO_FORCE" = "1" -a "$DRY_RUN" = "1" ]; then
    pod2usage -exit 0 "$0"
    echo "ERROR: --force and --dry-run are incompatible" >&2
    exit 1
elif [ "$DO_ALL" = "1" ]; then
    assert_btrfs_tools
    if [ -z "$1" ]; then
        for MOUNTPOINT in $(list_btrfs_mountpoints); do
            do_multiple "$DO_ACTION" "$MOUNTPOINT"
            SVTMP=$(mktemp)
            list_subvolumes "$MOUNTPOINT" > "$SVTMP"
            while read SUBVOL
            do
                do_multiple "$DO_ACTION" "$SUBVOL"
            done < "$SVTMP"
            rm "$SVTMP"
            report_subvols_excluded "$MOUNTPOINT" >&2
        done
    elif [ -z "$2" ]; then
        # Repeat the container filesystem here, so that it's included
        do_multiple "$DO_ACTION" "$1"
        # We write list_subvolumes to a file otherwise we clog up stdin from
        # things in do_multiple which also use while read foo
        SVTMP=$(mktemp)
        list_subvolumes "$1" > "$SVTMP"
        while read SUBVOL
        do
            do_multiple "$DO_ACTION" "$SUBVOL"
        done < "$SVTMP"
        rm "$SVTMP"
        report_subvols_excluded "$1" >&2
    else
        pod2usage -exit 0 "$0"
        echo "ERROR: Extraneous argument '$2'" >&2
        exit 1
    fi
else
    assert_btrfs_tools
    do_multiple "$DO_ACTION" "$@"
fi
if [ -n "$MISSING_SUBVOLS_EXCL_FILE" ]; then
    rm "$SNAZZER_SUBVOLS_EXCLUDE_FILE";
fi

exit

__END__
=head1 NAME

snazzer - create read-only C</subvol/.snapshotz/[isodate]> btrfs snapshots,
offers snapshot pruning and measurement

=head1 SYNOPSIS

  snazzer [--prune|--measure [--force ]] [--dry-run] --all

  snazzer [--prune|--measure [--force ]] [--dry-run] --all [mountpoint]

  snazzer [--prune|--measure [--force ]] [--dry-run] subvol1 [subvol2 [...]]

=head1 DESCRIPTION

Examples:

Snapshot all non-excluded subvols on all mounted btrfs filesystems:

  snazzer --all

Prune all non-excluded subvols on all mounted btrfs filesystems:

  snazzer --prune --force --all

Append output of B<snazzer-measure> to
C</path/to/subvol/.snapshotz/.measurements/[isodate]> for all snapshots of all
subvolumes on all mounted btrfs filesytems (slow!):

  snazzer --measure --force --all

As above, skipping snapshots already measured by this host (recommended):

  snazzer --measure --all

Print rather than execute commands for snapshotting all non-excluded subvols for
the filesystem mounted at /mnt (including /mnt itself):

  snazzer --dry-run --all /mnt

Prune only the explicitly named subvols at /srv, /var/log and root:

  snazzer --prune /srv /var/log /

=head1 OPTIONS

=over

=item B<--all> B<[mountpoint]>: act on all subvolumes under mountpoint. If
mountpoint is omitted, B<snazzer> acts on all mounted btrfs filesystems.

=item B<--prune>: delete rather than create snapshots. Exactly which are no
longer needed is B<snazzer-prune-candidates>'s role, documented separately

=item B<--measure>: append output of B<snazzer-measure> to
C</path/to/subvol/.snapshotz/.measurements/[isodate]> By default, only snapshots
which haven't been measured by this hostname are updated - use B<--force> to
measure all snapshots

=item B<--force>: required for B<--prune> to carry out any pruning operation.
For B<--measure>, this switch overrides the default behaviour of skipping
snapshots already measured by current hostname

=item B<--list-subvolumes>: list subvolumes that would be acted on

=item B<--list-snapshots>: list snapshots under subvolumes as above

=item B<--dry-run>: print rather than execute commands that would be run

=item B<--help>: Brief help message

=item B<--man>: Full documentation

=item B<--man-roff>: Full documentation as *roff output, Eg:

    snazzer --man-roff | nroff -man

=item B<--man-markdown>: Full documentation as markdown output, Eg:

    snazzer --man-markdown > snazzer-manpage.md

=item B<--generate-test-img> C<file.img>: create btrfs image for testing

=back

=head1 ENVIRONMENT

=over

=item * SNAZZER_SUBVOLS_EXCLUDE_FILE

Filename of newline separated list of shell glob patterns of subvolume pathnames
which should be excluded from C<snazzer --all> invocations; compatible with
C<--exclude-from> for B<du> and B<tar>.  Examples of subvolume patterns to
exclude from regular snapshotting: *secret*, /var/cache, /var/lib/docker/btrfs,
.snapshots.  B<NOTE:> C<.snapshotz> is always excluded.
Default:

  SNAZZER_SUBVOLS_EXCLUDE_FILE="/etc/snazzer/exclude.patterns"

=item * SNAZZER_USE_UTC=1

For snapshot naming and B<snazzer-measure> output use UTC times of the form
C<YYYY-MM-DDTHHMMSSZ> instead of local time+offset C<YYYY-MM-DDTHHMMSS+hhmm>

=back

=head1 BUGS AND LIMITATIONS

=over

=item * Snapshot naming

A choice has been made to mint a single datetime string which is used for all
snapshot names in a given B<snazzer> snapshot invocation, regardless of how long
or at which exact time the snapshotting process takes place for each subvolume.
This makes for consistency across all subvolumes and filesystems, so that
identifying which snapshots were part of a given snapshotting run is possible.
If the actual datetime of the snapshot event is important to you, this is
available from the C<btrfs subvolume show> command.

=item * BTRFS subvolume path name assumption

An assumption has been made that a subvolume will mounted under the same path
(relative to mountpoint) as its path name indicated by C<btrfs subvolume list>.
If you have manually mounted subvolumes under mountpoints inconsistent with this
assumption, breakage will occur.

=item * SNAZZER_SUBVOLS_EXCLUDE_FILE is used with grep -v

A minimal (possibly buggy/incomplete) attempt is made to convert the shell glob
patterns in this file to a regex suitable for grep -v. The assumption is that
the exclude patterns file should only contain "boring" paths. Obvious regex
characters are escaped, however there are likely many possible hostile path glob
patterns which will break things.

=item * .snapshot_measurements.exclude is a work-around to the btrfs atime bug

Snapshots may include empty directories under which some other subvol may have
existed in the original, snapshotted subvolume. However, btrfs has a bug where
these empty directories behave differently to empty directories created with
C<mkdir>: atimes always return with the current local time, which is obvioulsy
different from one second to the next. So we have no hope of creating
reproducible shasums or PGP signatures unless those directories are excluded
from our measurements of the snapshot. See also: 
L<https://bugzilla.kernel.org/show_bug.cgi?id=95201>

=back

=head1 EXIT STATUS

B<snazzer> will abort with an error message printed to STDERR and non-zero exit
status under the following conditions:

=over

=item 1. invalid arguments

=item 2. path is not a filesystem mountpoint

=item 3. one or more paths were not btrfs subvolumes

=item 4. prune expected /path/to/subvol/.snapshotz directory which was missing

=item 5. prune expected --dry-run or --force

=item 6. tried to write a .snapshot_measurements.exclude file in the snapshot
root, but it already exists in the current subvolume

=item 7. tried to perform snapshot measurements while existing measurements are
already in progress, check lock dir at /var/run/snazzer-measure.lock

=item 9. tried to display man page with a formatter which is not installed

=item 10. missing C<snazzer-measure> or C<snazzer-prune-candidates> from PATH

=item 11. missing C<btrfs> command from PATH

=back

=head1 SEE ALSO

snazzer-measure, snazzer-prune-candidates, snazzer-receive

=head1 AUTHOR

Paul Harvey <csirac2@gmail.com>, https://github.com/csirac2/snazzer

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015, Paul Harvey <csirac2@gmail.com> All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
=cut

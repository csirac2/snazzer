#!/bin/sh
set -e
SNAZZER_VERSION=0.2
SNAZZER_SUBVOLS_EXCLUDE_FILE_TMP=0
SNAZZER_SNAPSHOTZ_PERMS=0755

if [ "$(id -u)" = "0" ]; then
    SUDO=""
else
    SUDO="sudo"
fi

dry_list_snapshots() {
    HOST="$1"
    shift
    cat <<CMD
    ssh "$HOST" "$SUDO snazzer --list-snapshots $(
        while [ -n "$1" ]; do
            echo -n "'"; echo -n "$1" | sed "s|'|'\\\\''|g"; echo -n "' "
            shift
        done
    )"
CMD
}

do_list_snapshots() {
    # Don't forget to copy the lines below verbatim into dry_list_snapshots()
    HOST="$1"
    shift
    # Don't forget to copy the lines below into dry_list_snapshots() between CMD
    ssh "$HOST" "$SUDO snazzer --list-snapshots $(
        while [ -n "$1" ]; do
            echo -n "'"; echo -n "$1" | sed "s|'|'\\\\''|g"; echo -n "' "
            shift
        done
    )"
}

list_remote_snapshot_measurements() {
    HOST="$1"
    HOST_ESC=$(echo "$1" | sed "s|'|'\\\\''|g")
    SUBVOL_ESC=$(echo "$2" | sed "s|'|'\\\\''|g")
ssh "$HOST" "$SUDO grep -srl '^> on $HOST_ESC at ' \
    '$SUBVOL_ESC/.snapshotz/.measurements/' || true" | sed "s|^.*/||g"
}

dry_send() {
    HOST=$1
    SUBVOL_PATH=$2
    SNAP_PATH=$3
    SNAP_PATH_ESC=$(echo "$SNAP_PATH" | sed "s|'|'\\\\''|g")
    SNAP_PARENT_PATH_ESC=$(echo "$4" | sed "s|'|'\\\\''|g")
    SNAP_NAME=$(basename "$SNAP_PATH")
    PARENT_SWITCH=""
    if [ -n "$SNAP_PARENT_PATH_ESC" ]; then
        PARENT_SWITCH="-p '$SNAP_PARENT_PATH_ESC'" 
    fi
    cat <<CMD
    $SUDO mkdir --mode="$SNAZZER_SNAPSHOTZ_PERMS" \
        "$SUBVOL_PATH/.snapshotz/.incomplete"
    ssh "$HOST" "$SUDO btrfs send '$SNAP_PATH_ESC' $PARENT_SWITCH" \
        2>/dev/null | $SUDO btrfs receive "$SUBVOL_PATH/.snapshotz/.incomplete"
    $SUDO btrfs subvolume snapshot -r \
        "$SUBVOL_PATH/.snapshotz/.incomplete/$SNAP_NAME" \
        "$SUBVOL_PATH/.snapshotz/" >/dev/null
    $SUDO btrfs subvolume delete \
        "$SUBVOL_PATH/.snapshotz/.incomplete/$SNAP_NAME" >/dev/null
    $SUDO rmdir "$SUBVOL_PATH/.snapshotz/.incomplete"
CMD
}

do_send() {
    # Don't forget to copy the lines below verbatim into dry_send()
    HOST=$1
    SUBVOL_PATH=$2
    SNAP_PATH=$3
    SNAP_PATH_ESC=$(echo "$SNAP_PATH" | sed "s|'|'\\\\''|g")
    SNAP_PARENT_PATH_ESC=$(echo "$4" | sed "s|'|'\\\\''|g")
    SNAP_NAME=$(basename "$SNAP_PATH")
    PARENT_SWITCH=""
    if [ -n "$SNAP_PARENT_PATH_ESC" ]; then
        PARENT_SWITCH="-p '$SNAP_PARENT_PATH_ESC'" 
    fi
    # Don't forget to copy the lines below into dry_send() between CMD heredoc
    $SUDO mkdir --mode="$SNAZZER_SNAPSHOTZ_PERMS" \
        "$SUBVOL_PATH/.snapshotz/.incomplete"
    ssh "$HOST" "$SUDO btrfs send '$SNAP_PATH_ESC' $PARENT_SWITCH" \
        2>/dev/null | $SUDO btrfs receive "$SUBVOL_PATH/.snapshotz/.incomplete"
    $SUDO btrfs subvolume snapshot -r \
        "$SUBVOL_PATH/.snapshotz/.incomplete/$SNAP_NAME" \
        "$SUBVOL_PATH/.snapshotz/" >/dev/null
    $SUDO btrfs subvolume delete \
        "$SUBVOL_PATH/.snapshotz/.incomplete/$SNAP_NAME" >/dev/null
    $SUDO rmdir "$SUBVOL_PATH/.snapshotz/.incomplete"
}

dry_copy() {
    HOST=$1
    SUBVOL_REMOTEPATH=$2
    SUBVOL_LOCALPATH=$3
    SUBVOL_REMOTEPATH_ESC=$(echo "$SUBVOL_REMOTEPATH" | sed "s|'|'\\\\''|g")
    SNAP_NAME=$4
    cat <<CMD
    $SUDO mkdir -vp --mode="$SNAZZER_SNAPSHOTZ_PERMS" \
        "$SUBVOL_REMOTEPATH/.snapshotz/.measurements"
    ssh "$HOST" "$SUDO cat \
        '$SUBVOL_REMOTEPATH_ESC/.snapshotz/.measurements/$SNAP_NAME'" | \
        $SUDO tee -a "$SUBVOL_LOCALPATH/.snapshotz/.measurements/$SNAP_NAME" \
        >/dev/null
CMD
}

do_copy() {
    # Don't forget to copy the lines below verbatim into dry_copy()
    HOST=$1
    SUBVOL_REMOTEPATH=$2
    SUBVOL_LOCALPATH=$3
    SUBVOL_REMOTEPATH_ESC=$(echo "$SUBVOL_REMOTEPATH" | sed "s|'|'\\\\''|g")
    SNAP_NAME=$4
    # Don't forget to copy the lines below verbatim into dry_copy() between CMD
    $SUDO mkdir -vp --mode="$SNAZZER_SNAPSHOTZ_PERMS" \
        "$SUBVOL_REMOTEPATH/.snapshotz/.measurements"
    ssh "$HOST" "$SUDO cat \
        '$SUBVOL_REMOTEPATH_ESC/.snapshotz/.measurements/$SNAP_NAME'" | \
        $SUDO tee -a "$SUBVOL_LOCALPATH/.snapshotz/.measurements/$SNAP_NAME" \
        >/dev/null
}

create_subvol() {
    DIR="$1"
    PARENT=$(dirname "$DIR")
    if [ "$DIR" != "$PARENT" -a "$PARENT" != "." ]; then
        $SUDO mkdir -vp "$PARENT"
    fi
    $SUDO btrfs subvolume create "$DIR"
    $SUDO mkdir --mode="$SNAZZER_SNAPSHOTZ_PERMS" -vp "$DIR/.snapshotz"
}

is_subvol() {
    DIR=$1

    if $SUDO btrfs subvolume show "$DIR" >/dev/null 2>&1; then
        echo 1
    else
        echo 0
    fi
}

dispatch_copy() {
    HOST=$1
    SUBVOL_REMOTEPATH=$2
    SUBVOL_LOCALPATH=$3
    SNAP_NAME=$4
    if [ "$DRY_RUN" != "0" ]; then
        dry_copy "$HOST" "$SUBVOL_REMOTEPATH" "$SUBVOL_LOCALPATH" "$SNAP_NAME"
    else
        do_copy "$HOST" "$SUBVOL_REMOTEPATH" "$SUBVOL_LOCALPATH" "$SNAP_NAME"
    fi
}

do_subvolume_measurements() {
    HOST="$1"
    SUBVOL="$2"
    if [ -z "$SUBVOL" ]; then
        SUBVOL_RELPATH="."
    else
        SUBVOL_RELPATH="$SUBVOL"
    fi
    SUBVOL_RELPATH_ESC=$(echo "$SUBVOL_RELPATH" | sed "s|'|'\\\\''|g") 
    echo -n "  appending measurements..."
    if $SUDO test -e "$SUBVOL_RELPATH/.snapshotz/.incomplete"; then
        cat <<HERE >&2

ERROR: $SUBVOL_RELPATH/.snapshotz/.incomplete exists. Another instance is already
running, or a previous invocation was interrupted. If you are sure no other
instances are already running, remove this directory and snapshots under it:

btrfs subvolume delete '$SUBVOL_RELPATH_ESC/.snapshotz/.incomplete'/*
rmdir '$SUBVOL_RELPATH_ESC/.snapshotz/.incomplete'
HERE
        exit 2
    fi
    if [ "$(is_subvol "$SUBVOL_RELPATH")" != "1" ]; then
        echo "ERROR: $SUBVOL_RELPATH not a subvolume, this shouldn't happen."
        exit
    fi
    if ! $SUDO test -e "$SUBVOL_RELPATH/.snapshotz/.measurements"; then
        $SUDO mkdir --mode="$SNAZZER_SNAPSHOTZ_PERMS" \
            "$SUBVOL_RELPATH/.snapshotz/.measurements"
    fi
    SNAPSHOTS=$($SUDO ls "$SUBVOL_RELPATH/.snapshotz")
    MEAS_WANT=$(mktemp)
    MEAS_ABSENT=$($SUDO grep -srL "^> on $HOST at " \
        "$SUBVOL_RELPATH/.snapshotz/.measurements/" | sed "s|^.*/||g")
    MEAS_REMOTE=$(list_remote_snapshot_measurements "$HOST" "/$SUBVOL_RELPATH")
    # 1. Print snapshot measurements that we have locally but are missing
    #    mentions of remote $HOST;
    # 2. Print snapshot measurements available on the remote $HOST
    # 3. Write the union of these two lists (duplicates only) as a list of the
    #    snapshot names which we should grab remote $HOST's measurements of
    cat <<HERE | sort | uniq -d > "$MEAS_WANT"
$(echo "$MEAS_ABSENT")
$(echo "$MEAS_REMOTE")
HERE
    NUM_WANT=$(wc -l "$MEAS_WANT" | cut -d ' ' -f 1)
    NUM_SNAP=$(echo "$SNAPSHOTS" | wc -l | cut -d ' ' -f 1)
    NUM_COPY=0
    NUM_REMOTE=$(echo "$MEAS_REMOTE" | wc -l | cut -d ' ' -f 1)
    while read SNAP_NAME
    do
        dispatch_copy "$HOST" "/$SUBVOL_RELPATH" "$SUBVOL_RELPATH" "$SNAP_NAME"
        NUM_COPY=$(expr $NUM_COPY + 1)
    done < "$MEAS_WANT"
    echo "$MEAS_REMOTE" > "$MEAS_WANT"
    while read SNAP_NAME
    do
        if $SUDO test -e  "$SUBVOL_RELPATH/.snapshotz/$SNAP_NAME" && \
            ! $SUDO test -e \
            "$SUBVOL_RELPATH/.snapshotz/.measurements/$SNAP_NAME"; then
            dispatch_copy "$HOST" "/$SUBVOL_RELPATH" "$SUBVOL_RELPATH" "$SNAP_NAME"
            NUM_COPY=$(expr $NUM_COPY + 1)
        fi
    done < "$MEAS_WANT"
    rm "$MEAS_WANT"
    echo " $NUM_COPY of $NUM_REMOTE."
}

do_subvolume() {
    HOST=$1
    SUBVOL=$2
    if [ -z "$SUBVOL" ]; then
        SUBVOL_PATH="."
    else
        SUBVOL_PATH="$SUBVOL"
    fi
    SUBVOL_PATH_ESC=$(echo "$SUBVOL_PATH" | sed "s|'|'\\\\''|g") 
    echo "subvolume $SUBVOL_PATH:"
    if $SUDO test -e "$SUBVOL_PATH/.snapshotz/.incomplete"; then
        cat <<HERE >&2

ERROR: $SUBVOL_PATH/.snapshotz/.incomplete exists. Another instance is already
running, or a previous invocation was interrupted. If you are sure no other
instances are already running, remove this directory and snapshots under it:

btrfs subvolume delete '$SUBVOL_PATH_ESC/.snapshotz/.incomplete'/*
rmdir '$SUBVOL_PATH_ESC/.snapshotz/.incomplete'
HERE
        exit 2
    fi
    if [ "$(is_subvol "$SUBVOL_PATH")" != "1" ]; then
        create_subvol "$SUBVOL_PATH"
    fi
    if ! $SUDO test -e "$SUBVOL_PATH/.snapshotz"; then
        $SUDO mkdir --mode="$SNAZZER_SNAPSHOTZ_PERMS" \
            "$SUBVOL_PATH/.snapshotz"
    fi
    # Last snapshot seen in the local target fs
    PREV_SNAP=
    SNAPSHOTS=$(do_list_snapshots "$HOST" "/$SUBVOL_PATH")
    SNAP_WANT=$(mktemp)
    echo "$SNAPSHOTS" | snazzer-prune-candidates --invert > "$SNAP_WANT"
    NUM_WANT=$(wc -l "$SNAP_WANT" | cut -d ' ' -f 1)
    NUM_SNAP=$(echo "$SNAPSHOTS" | wc -l | cut -d ' ' -f 1)
    # SMELL: that expr errors when the answer is zero, is why sh scripting sucks
    NUM_PRUN=$(expr $NUM_SNAP - $NUM_WANT || true)
    NUM_RECV=0
    NUM_SKIP=0
    while read SNAPSHOT
    do
        SUBVOL_PATH=$(echo "$SNAPSHOT" | sed 's|^/*\(.*\)/\.snapshotz/.*|\1|g')
        SNAP_PATH=$(echo "$SNAPSHOT" | sed 's|^/||g')
        if [ -z "$SUBVOL_PATH" ]; then
            SUBVOL_PATH="."
        fi
        if $SUDO test -e "$SNAP_PATH"; then
            NUM_SKIP=$(expr $NUM_SKIP + 1)
        else
            NUM_RECV=$(expr $NUM_RECV + 1)
            if [ -n "$PREV_SNAP" ]; then PREV_SNAP="/$PREV_SNAP"; fi
            if [ "$DRY_RUN" != "0" ]; then
                dry_send \
                    "$HOST" "$SUBVOL_PATH" "$SNAP_PATH" "$PREV_SNAP"
            else
                do_send \
                    "$HOST" "$SUBVOL_PATH" "$SNAP_PATH" "$PREV_SNAP"
            fi
        fi
        PREV_SNAP="$SNAP_PATH"
    done < "$SNAP_WANT"
    rm "$SNAP_WANT"
    echo -n "  $NUM_RECV of $NUM_SNAP snapshots received "
    echo "($NUM_PRUN pruned, $NUM_WANT considered, $NUM_SKIP skipped)"
}

#SMELL: Assumes --list-snapshots lines are grouped by subvol, ordered by date
#FIXME: Subvols containing mixed timezone snapshots will use suboptimal parents
do_host() {
    HOST=$1
    NUM_SUBVOL=0
    LIST_ERR=$(mktemp)
    LIST_OUT=$(mktemp)
    shift
    do_list_snapshots "$HOST" "$@" 2>"$LIST_ERR" | \
        sed 's|^/*\(.*\)/\.snapshotz/.*|\1|g' | sort | uniq > "$LIST_OUT"
    NUM_SUBVOL=$(wc -l "$LIST_OUT" | cut -d ' ' -f 1)
    # We'd while read FOO ... done < "foo.txt", but can't nest them
    I=0
    while test "$I" -lt "$NUM_SUBVOL"; do
        I=$(expr $I + 1)
        SUBVOL=$(head -n $I "$LIST_OUT" | tail -n 1)
        do_subvolume "$HOST" "$SUBVOL"
        do_subvolume_measurements "$HOST" "$SUBVOL"
    done
    echo -n "Processed $NUM_SUBVOL subvolume(s)."
    if [ -s "$LIST_ERR" ]; then
        echo " Additional output from:"
        echo -n "  "
        dry_list_snapshots "$HOST" "$@"
        grep . "$LIST_ERR" | sed 's/^/    /g'
    else
        echo ""
    fi
    rm "$LIST_OUT"
    rm "$LIST_ERR"
}

DRY_RUN=0

while [ "$(echo "$1" | grep -c "^-")" != 0 ]
do
    case "$1" in
        -h | --help ) pod2usage -exit 0 "$0"; exit ;;
             --man ) pod2usage -exit 0 -verbose 3 "$0"; exit ;;
             --man-roff ) pod2man --release=$SNAZZER_VERSION "$0"; exit ;;
             --man-markdown )
             cat <<HERE | perl -Mstrict
if ( eval { require Pod::Markdown; 1; } ) {
    Pod::Markdown->new->filter('$0');
}
else {
    print STDERR "ERROR: --man-markdown requires Pod::Markdown\n\$@\n";
    exit 9;
}
HERE
                 exit ;;
        -d | --dry-run ) DRY_RUN=1; ;;
        * ) echo "ERROR: Invalid argument '$1'" >&2 ; exit ;;
    esac
    shift
done

if [ -z "$1" ]; then
    pod2usage -exit 0 "$0"
    echo "ERROR: Missing argument" >&2
    exit 1
fi

do_host "$@"

exit

__END__
=head1 NAME

snazzer-receive - receive remote snazzer snapshots to current working dir

=head1 SYNOPSIS

  snazzer-receive [--dry-run] host --all [/path/to/btrfs/mountpoint]

  snazzer-receive [--dry-run] host [/remote/subvol1 [/subvol2 [..]]]

=head1 DESCRIPTION

First, B<snazzer-receive> obtains a list of snapshots on the remote host. This
is achieved by processing the first non-option positional argument as an ssh
hostname with which to run C<snazzer --list-snapshots [args]> remotely, where
[args] are all subsequent B<snazzer-receive> arguments (such as C<--all> or
C</remote/subvol1>).

B<snazzer-receive> then iterates through this list of snapshots, recreating a
filesystem similar to that of the remote host's by creating subvolumes and
C<.snapshotz> directories where necessary. Missing snapshots are instantiated
directly with C<btrfs send> and C<btrfs receive>, using C<btrfs send -p [parent]>
where possible to reduce transport overhead of incremental snapshots.

Rather than offer ssh user/port/host specifications through B<snazzer-receive>,
it is assumed all remote hosts are properly configured through your ssh config
file usually at C<$HOME/.ssh/config>.

=head1 OPTIONS

=over

=item B<--dry-run>: print rather than execute commands that would be run

=item B<--help>: Brief help message

=item B<--man>: Full documentation

=item B<--man-roff>: Full documentation as *roff output, Eg:

    snazzer --man-roff | nroff -man

=item B<--man-markdown>: Full documentation as markdown output, Eg:

    snazzer --man-markdown > snazzer-manpage.md

=back

=head1 ENVIRONMENT

=head1 BUGS AND LIMITATIONS

B<NOTE 1:> B<snazzer-receive> tries to recreate a filesystem similar to that of
the remote host, starting at the current working directory which represents the
root filesystem. If the remote host has a root btrfs filesystem, this means that
the current working directory should itself also be a btrfs subvolume in order
to receive snapshots under ./.snapshotz. However, B<snazzer-receive> will be
unable to replace the current working directory with a btrfs subvolume if it
isn't already one.

Therefore, if required, ensure the current working directory is already a btrfs
subvolume prior to running B<snazzer-receive> if you need to receive btrfs root.

B<NOTE 2:> C<snazzer-receive host --all> may process a list of snapshots
spanning multiple separate btrfs filesystems on a remote host, but unless extra
steps are taken they will all be received into the same local filesystem under
the current working directory. If this is not what you want, manually mount
filesystems under the current working directory before running
B<snazzer-receive>.

=head1 EXIT STATUS

B<snazzer-receive> will abort with an error message printed to STDERR and
non-zero exit status under the following conditions:

=over

=item 1. invalid arguments

=item 2. C<.snapshotz/.incomplete> already exists at a given destination subvolume

=item 9. tried to display man page with a formatter which is not installed

=back

=head1 TODO

=over

=item 1. improve fetch/append of remote host's measurements

B<snazzer-receive> currently does some clumsy concatenation of the remote host's
measurement file onto the local measurement file for a given snapshot if the
local measurement file is either missing or does not mention that remote host's
hostname. Whilst this supports the simple use-case of wanting to obtain initial
measurements performed on a remote host, once a remote host's measurements have
been appended there is no attempt to append any further measurement results onto
the local measurements file.  If this bothers you, please report detailed
use-cases to the author (patches welcome).

=item 2. document sudo and recommended sudoers files

The snazzer project has been written with the assumption that most systems
administrators will not want to run remote ssh commands either from or to the
root user. When a snazzer script requires root privileges and uid 0 is not
detected, these commands are prefixed with C<sudo>. Example sudoers files to
restrict which commands are required for sudo operation shall be included at
some point.

=item 3. include restricted wrapper script to be used as ssh forced command

The snazzer project assumes that systems administrators would prefer to restrict
the possible exposure of a dedicated snazzer remote user account, even if sudo
is locked down. To that end, a wrapper script shall be provided which restricts
possible ssh remote commands to only the few actually necessary for snazzer
operation.

Even so, commands which snazzer relies on such as C<sudo btrfs send> are
extremely dangerous no matter if it's the only command allowed by the system -
securing ssh keys is of utmost importance; consider protecting ssh keys with
smartcards, TPM, hardware OTP solution such as Yubi/GoldKeys etc.

=back

=head1 SEE ALSO

snazzer, snazzer-measure, snazzer-prune-candidates

=head1 AUTHOR

Paul Harvey <csirac2@gmail.com>, https://github.com/csirac2/snazzer

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015, Paul Harvey <csirac2@gmail.com> All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
=cut
